!function (e, t, n, a) { var r; r = /android|iPad|iPod|iPhone|arm/.test(navigator.platform) ? "ontouchstart" in n.documentElement : !1; var i = r ? "touchstart" : "mousedown", l = r ? "touchmove" : "mousemove", o = r ? "touchend" : "mouseup"; r && e.each("touchstart touchmove touchend".split(" "), function (t, n) { e.event.fixHooks[n] = e.event.mouseHooks }), e(n).ready(function () { function t(e) { for (var t = {}, n = e.match(/([^;:]+)/g) || []; n.length;) t[n.shift()] = n.shift().trim(); return t } e("table").each(function () { "dnd" == e(this).data("table") && e(this).tableDnD({ onDragStyle: e(this).data("ondragstyle") && t(e(this).data("ondragstyle")) || null, onDropStyle: e(this).data("ondropstyle") && t(e(this).data("ondropstyle")) || null, onDragClass: e(this).data("ondragclass") == a && "tDnD_whileDrag" || e(this).data("ondragclass"), onDrop: e(this).data("ondrop") && new Function("table", "row", e(this).data("ondrop")), onDragStart: e(this).data("ondragstart") && new Function("table", "row", e(this).data("ondragstart")), scrollAmount: e(this).data("scrollamount") || 5, sensitivity: e(this).data("sensitivity") || 10, hierarchyLevel: e(this).data("hierarchylevel") || 0, indentArtifact: e(this).data("indentartifact") || '<div class="indent">&nbsp;</div>', autoWidthAdjust: e(this).data("autowidthadjust") || !0, autoCleanRelations: e(this).data("autocleanrelations") || !0, jsonPretifySeparator: e(this).data("jsonpretifyseparator") || "	", serializeRegexp: e(this).data("serializeregexp") && new RegExp(e(this).data("serializeregexp")) || /[^\-]*$/, serializeParamName: e(this).data("serializeparamname") || !1, dragHandle: e(this).data("draghandle") || null }) }) }), t.jQuery.tableDnD = { currentTable: null, dragObject: null, mouseOffset: null, oldX: 0, oldY: 0, build: function (t) { return this.each(function () { this.tableDnDConfig = e.extend({ onDragStyle: null, onDropStyle: null, onDragClass: "tDnD_whileDrag", onDrop: null, onDragStart: null, scrollAmount: 5, sensitivity: 10, hierarchyLevel: 0, indentArtifact: '<div class="indent">&nbsp;</div>', autoWidthAdjust: !0, autoCleanRelations: !0, jsonPretifySeparator: "	", serializeRegexp: /[^\-]*$/, serializeParamName: !1, dragHandle: null }, t || {}), e.tableDnD.makeDraggable(this), this.tableDnDConfig.hierarchyLevel && e.tableDnD.makeIndented(this) }), this }, makeIndented: function (t) { var n, a, r = t.tableDnDConfig, i = t.rows, l = e(i).first().find("td:first")[0], o = 0, s = 0; if (e(t).hasClass("indtd")) return null; a = e(t).addClass("indtd").attr("style"), e(t).css({ whiteSpace: "nowrap" }); for (var d = 0; d < i.length; d++) s < e(i[d]).find("td:first").text().length && (s = e(i[d]).find("td:first").text().length, n = d); for (e(l).css({ width: "auto" }), d = 0; d < r.hierarchyLevel; d++) e(i[n]).find("td:first").prepend(r.indentArtifact); for (l && e(l).css({ width: l.offsetWidth }), a && e(t).css(a), d = 0; d < r.hierarchyLevel; d++) e(i[n]).find("td:first").children(":first").remove(); return r.hierarchyLevel && e(i).each(function () { o = e(this).data("level") || 0, o <= r.hierarchyLevel && e(this).data("level", o) || e(this).data("level", 0); for (var t = 0; t < e(this).data("level") ; t++) e(this).find("td:first").prepend(r.indentArtifact) }), this }, makeDraggable: function (t) { var n = t.tableDnDConfig; e(t).on(i, "tr " + n.dragHandle, function (a) { e.tableDnD.initialiseDrag(e(this), t, this, a, n) }) }, currentOrder: function () { var t = this.currentTable.rows; return e.map(t, function (t) { return (e(t).data("level") + t.id).replace(/\s/g, "") }).join("") }, initialiseDrag: function (t, a, r, i, s) { this.dragObject = t.closest("tr")[0], this.dragCell = t.closest("th")[0], this.currentTable = a, this.columns = this.currentTable.tHead.childNodes[0].cells, this.mouseOffset = this.getMouseOffset(r, i), this.originalOrder = this.currentOrder(), e(n).bind(l, this.mousemove).bind(o, this.mouseup), s.onDragStart && s.onDragStart(a, r) }, updateTables: function () { this.each(function () { this.tableDnDConfig && e.tableDnD.makeDraggable(this) }) }, mouseCoords: function (e) { return e.pageX || e.pageY ? { x: e.pageX, y: e.pageY } : { x: e.clientX + n.body.scrollLeft - n.body.clientLeft, y: e.clientY + n.body.scrollTop - n.body.clientTop } }, getMouseOffset: function (e, n) { var a, r; return n = n || t.event, r = this.getPosition(e), a = this.mouseCoords(n), { x: a.x - r.x, y: a.y - r.y } }, getPosition: function (e) { var t = 0, n = 0; if ("TH" != e.nodeName) { for (0 == e.offsetHeight && (e = e.firstChild) ; e.offsetParent;) t += e.offsetLeft, n += e.offsetTop, e = e.offsetParent; t += e.offsetLeft, n += e.offsetTop } else t = e.offsetLeft, n = e.offsetTop; return { x: t, y: n } }, autoScroll: function (e) { var a = this.currentTable.tableDnDConfig, r = t.pageYOffset, i = t.innerHeight ? t.innerHeight : n.documentElement.clientHeight ? n.documentElement.clientHeight : n.body.clientHeight; n.all && ("undefined" != typeof n.compatMode && "BackCompat" != n.compatMode ? r = n.documentElement.scrollTop : "undefined" != typeof n.body && (r = n.body.scrollTop)), e.y - r < a.scrollAmount && t.scrollBy(0, -a.scrollAmount) || i - (e.y - r) < a.scrollAmount && t.scrollBy(0, a.scrollAmount) }, moveVerticle: function (e, t) { 0 != e.vertical && t && this.dragObject != t && this.dragObject.parentNode == t.parentNode && (0 > e.vertical && this.dragObject.parentNode.insertBefore(this.dragObject, t.nextSibling) || 0 < e.vertical && this.dragObject.parentNode.insertBefore(this.dragObject, t)) }, moveHorizontal: function (t, n) { var a, r, i = this.currentTable.tableDnDConfig; if (!i.hierarchyLevel || 0 == t.horizontal || !n || this.dragCell == n) return null; var l, o, s = this.dragCell.cellIndex, d = n.cellIndex, f = function (e, t) { var n = e.parentNode, a = e.nextSibling === t ? e : e.nextSibling; t.parentNode.insertBefore(e, t), n.insertBefore(t, a) }; if (d > s) for (a = s; d > a; ++a) for (r = 0; r < this.currentTable.rows.length; ++r) l = e(this.currentTable.rows[r]).find(0 === r ? "th" : "td")[a], l && (o = l.nextSibling, f(l, o)); else for (a = s; a > d; --a) for (r = 0; r < this.currentTable.rows.length; ++r) l = e(this.currentTable.rows[r]).find(0 === r ? "th" : "td")[a - 1], l && (o = l.nextSibling, f(l, o)) }, getTableOffset: function () { return { x: e(this.currentTable).offset().left, y: e(this.currentTable).offset().top } }, mousemove: function (t) { var n, a, r, i, l, o, s = e(e.tableDnD.dragObject), d = e.tableDnD.dragCell, f = e.tableDnD.currentTable.tableDnDConfig; if (t && t.preventDefault(), !e.tableDnD.dragObject) return !1; if ("touchmove" == t.type && event.preventDefault(), d ? f.onDragClass && e(d).addClass(f.onDragClass) : f.onDragClass && s.addClass(f.onDragClass) || s.css(f.onDragStyle), r = e.tableDnD.mouseCoords(t), d) { var h = e.tableDnD.getTableOffset(); l = r.x - h.x, o = r.y - h.y } else l = r.x - e.tableDnD.mouseOffset.x, o = r.y - e.tableDnD.mouseOffset.y; return e.tableDnD.autoScroll(r), i = e.tableDnD.findDragDirection(l, o), n = e.tableDnD.findDropTargetRow(s, o), d && (a = e.tableDnD.findDropTargetCell(d, l, i)), e.tableDnD.moveVerticle(i, n), e.tableDnD.moveHorizontal(i, a), !1 }, findDragDirection: function (e, t) { var n = this.currentTable.tableDnDConfig.sensitivity, a = this.oldX, r = this.oldY, i = a - n, l = a + n, o = r - n, s = r + n, d = { horizontal: e >= i && l >= e ? 0 : e > a ? -1 : 1, vertical: t >= o && s >= t ? 0 : t > r ? -1 : 1 }; return 0 != d.horizontal && (this.oldX = e), 0 != d.vertical && (this.oldY = t), d }, findDropTargetRow: function (t, n) { for (var a = 0, r = this.currentTable.rows, i = this.currentTable.tableDnDConfig, l = 0, o = null, s = 0; s < r.length; s++) if (o = r[s], l = this.getPosition(o).y, a = parseInt(o.offsetHeight) / 2, 0 == o.offsetHeight && (l = this.getPosition(o.firstChild).y, a = parseInt(o.firstChild.offsetHeight) / 2), n > l - a && l + a > n) return o == t || i.onAllowDrop && !i.onAllowDrop(t, o) || e(o).hasClass("nodrop") ? null : o; return null }, findDropTargetCell: function (n, a, r) { for (var i, l, o, s = this.columns, d = this.currentTable.tableDnDConfig, f = 0; f < s.length; f++) if (o = s[f], l = this.getPosition(o).x, i = o.offsetWidth, n.offsetWidth >= i) { if (a > l && l + i > a) return o == n || 0 === o.cellIndex || d.onAllowDrop && !d.onAllowDrop(t.draggedRow, row) || e(o).hasClass("nodrop") ? null : o } else if (r.horizontal > 0) { if (a > l && a < l + n.offsetWidth) return o == n || 0 === o.cellIndex || d.onAllowDrop && !d.onAllowDrop(t.draggedRow, row) || e(o).hasClass("nodrop") ? null : o } else if (r.horizontal < 0 && a > l + i - n.offsetWidth && l + i > a) return o == n || 0 === o.cellIndex || d.onAllowDrop && !d.onAllowDrop(t.draggedRow, row) || e(o).hasClass("nodrop") ? null : o; return null }, processMouseup: function () { if (!this.currentTable) return null; var t = this.currentTable.tableDnDConfig, a = this.dragObject, r = this.dragCell, i = 0, s = 0; return a || r ? (e(n).unbind(l, this.mousemove).unbind(o, this.mouseup), t.hierarchyLevel && t.autoCleanRelations && e(this.currentTable.rows).first().find("td:first").children().each(function () { s = e(this).parents("tr:first").data("level"), s && e(this).parents("tr:first").data("level", --s) && e(this).remove() }) && t.hierarchyLevel > 1 && e(this.currentTable.rows).each(function () { if (s = e(this).data("level"), s > 1) for (i = e(this).prev().data("level") ; s > i + 1;) e(this).find("td:first").children(":first").remove(), e(this).data("level", --s) }), t.onDragClass && e(a).removeClass(t.onDragClass) || e(a).css(t.onDropStyle), this.dragObject = null, this.dragCell = null, t.onDrop && e(a).hide().fadeIn("fast", function () { t.onDrop(this.currentTable, a, r) }), void (this.currentTable = null)) : null }, mouseup: function (t) { return t && t.preventDefault(), e.tableDnD.processMouseup(), !1 }, jsonize: function (e) { var t = this.currentTable; return e ? JSON.stringify(this.tableData(t), null, t.tableDnDConfig.jsonPretifySeparator) : JSON.stringify(this.tableData(t)) }, serialize: function () { return e.param(this.tableData(this.currentTable)) }, serializeTable: function (e) { for (var t = "", n = e.tableDnDConfig.serializeParamName || e.id, a = e.rows, r = 0; r < a.length; r++) { t.length > 0 && (t += "&"); var i = a[r].id; i && e.tableDnDConfig && e.tableDnDConfig.serializeRegexp && (i = i.match(e.tableDnDConfig.serializeRegexp)[0], t += n + "[]=" + i) } return t }, serializeTables: function () { var t = []; return e("table").each(function () { this.id && t.push(e.param(this.tableData(this))) }), t.join("&") }, tableData: function (t) { var n, a, r, i, l = t.tableDnDConfig, o = [], s = 0, d = 0, f = null, h = {}; if (t || (t = this.currentTable), !(t && t.id && t.rows && t.rows.length)) return { error: { code: 500, message: "Not a valid table, no serializable unique id provided." } }; i = l.autoCleanRelations && t.rows || e.makeArray(t.rows), a = l.serializeParamName || t.id, r = a, n = function (e) { return e && l && l.serializeRegexp ? e.match(l.serializeRegexp)[0] : e }, h[r] = [], !l.autoCleanRelations && e(i[0]).data("level") && i.unshift({ id: "undefined" }); for (var u = 0; u < i.length; u++) if (l.hierarchyLevel) { if (d = e(i[u]).data("level") || 0, 0 == d) r = a, o = []; else if (d > s) o.push([r, s]), r = n(i[u - 1].id); else if (s > d) for (var c = 0; c < o.length; c++) o[c][1] == d && (r = o[c][0]), o[c][1] >= s && (o[c][1] = 0); s = d, e.isArray(h[r]) || (h[r] = []), f = n(i[u].id), f && h[r].push(f) } else f = n(i[u].id), f && h[r].push(f); return h } }, t.jQuery.fn.extend({ tableDnD: e.tableDnD.build, tableDnDUpdate: e.tableDnD.updateTables, tableDnDSerialize: e.proxy(e.tableDnD.serialize, e.tableDnD), tableDnDSerializeAll: e.tableDnD.serializeTables, tableDnDData: e.proxy(e.tableDnD.tableData, e.tableDnD) }) }(window.jQuery, window, window.document);